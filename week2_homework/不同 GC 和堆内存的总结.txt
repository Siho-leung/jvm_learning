1、串行GC(SerialGC)
串行GC 对年轻代使用mark-copy（标记-复制） 算法，对老年代使用mark-sweep-compact（标记-清除-
整理）算法。
两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。
因此这种GC 算法不能充分利用多核CPU。不管有多少CPU 内核，JVM 在垃圾收集时都只能使用单个核心。
CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死。
该选项只适合几百MB 堆内存的JVM，而且是单核CPU 时比较有用。
2、并行GC(ParallelGC)
-XX:+UseParallelGC
-XX:+UseParallelOldGC
-XX:+UseParallelGC -XX:+UseParallelOldGC
年轻代和老年代的垃圾回收都会触发STW 事件。
在年轻代使用标记-复制（mark-copy）算法，在老年代使用标记-清除-整理（mark-sweepcompact）算法。
-XX：ParallelGCThreads=N 来指定GC 线程数， 其默认值为CPU 核心数。
并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
• 在GC 期间，所有CPU 内核都在并行清理垃圾，所以总暂停时间更短；
• 在两次GC 周期的间隔期，没有GC 线程在运行，不会消耗任何系统资源。
3、CMS GC
-XX:+UseConcMarkSweepGC
其对年轻代采用并行STW 方式的mark-copy (标记-复制)算法，对老年代主要使用并发mark-sweep (标记-清除)算法。
CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU 时。
默认情况下，CMS 使用的并发线程数等于CPU 核心数的1/4。
如果服务器是多核CPU，并且主要调优目标是降低GC 停顿导致的系统延迟，那么使用CMS 是个很明智的选择。
进行老年代的并发回收时，可能会伴随着多次年轻代的minor GC。
4、G1 GC
-XX:+UseG1GC
可设置预期的停顿时间，不会产生内存碎片。G1将整个堆划分成多个等大的独立区域(region)，
保留了新生代、老年代，但是不再是物理隔离，而是部分region的集合。G1跟踪各个Region里的垃圾回收价值大小
(回收所获得的空间大小以及所需时间的经验值；维护了一个优先列表，每次根据允许的回收时间，
优先回收价值最大的region(用最短的时间回收最多的垃圾)